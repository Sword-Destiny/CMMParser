options{    STATIC = false;    UNICODE_INPUT = true;}PARSER_BEGIN(CMMParser)package com.yuanhonglong.analysis.javaccAnalysis;public class CMMParser{}PARSER_END(CMMParser)SKIP :{    < " " >|   < "\t" >|   < "\n" >|   < "\r" >|   < "//" (~[ "\n" ])* "\n" >|   < "/*" (~[ "*" ])* "*"        (            ~[ "/" ] (~[ "*" ])* "*"        )*        "/" >}TOKEN :{    < DECIMAL_NUMBER :        [ "1"-"9" ] ([ "0"-"9" ])*    |   "0" >|   < REAL_NUMBER : ([ "0"-"9" ])+ "." ([ "0"-"9" ])* >|   < TRUE : "true" >|   < FALSE : "false" >|   < REAL : "real" >|   < INT : "int" >|   < BOOLEAN : "boolean" >|   < VOID : "void" >|   < PRE_LEN:"#length">|   < PRE_ADDRESS:"#address">|   < IF : "if" >|   < ELSE : "else" >|   < READ : "read" >|   < WRITE : "write" >|   < WHILE : "while" >|   < FOR : "for" >|   < BREAK : "break" >|   < CONTINUE : "continue" >|   < RETURN : "return" >|   < IDENTIFIER : [ "a"-"z", "A"-"Z", "_" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >}TOKEN :{    < L_SMALL_BRACKET : "(" >|   < R_SMALL_BRACKET : ")" >|   < L_LARGE_BRACKET : "{" >|   < R_LARGE_BRACKET : "}" >|   < L_MIDDLE_BRACKET : "[" >|   < R_MIDDLE_BRACKET : "]" >|   < SEMICOLON : ";" >|   < COMMA : "," >|   < DOT : "." >|   < STR :        "\""        (            (~[ "\"", "\\", "\n", "\r" ])        |            (                "\\"                (                    [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]                |   [ "0"-"7" ] ([ "0"-"7" ])?                |   [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]                )            )        )*        "\"" >}TOKEN :{    < ASSIGN : "=" >|   < GREATER_THAN : ">" >|   < LESS_THAN : "<" >|   < BANG : "!" >|   < TILDE : "~" >|   < DOUBLE_EQUAL : "==" >|   < LESS_EQUAL : "<=" >|   < GREATER_EQUAL : ">=" >|   < NOT_EQUAL : "!=" >|   < DOUBLE_OR : "||" >|   < DOUBLE_AND : "&&" >|   < INCREMENT : "++" >|   < DECREMENT : "--" >|   < PLUS : "+" >|   < MINUS : "-" >|   < STAR : "*" >|   < SLASH : "/" >|   < AND : "&" >|   < OR : "|" >|   < XOR : "^" >|   < PERCENT : "%" >|   < LSHIFT : "<<" >|   < RSHIFT : ">>" >|   < PLUSASSIGN : "+=" >|   < MINUSASSIGN : "-=" >|   < STARASSIGN : "*=" >|   < SLASHASSIGN : "/=" >|   < ANDASSIGN : "&=" >|   < ORASSIGN : "|=" >|   < XORASSIGN : "^=" >|   < PERCENTASSIGN : "%=" >|   < LSHIFTASSIGN : "<<=" >|   < RSHIFTASSIGN : ">>=" >}void Type() :{}{    (        < REAL >    |   < INT >    |   < BOOLEAN >    )    [ "[" < DECIMAL_NUMBER > "]" ]}void ReturnType() :{}{    Type()|   < VOID >}void FormalParameter() :{}{    Type() < IDENTIFIER >}void FormalParameters() :{}{    "("    [        FormalParameter()        (            "," FormalParameter()        )*    ]    ")"}void MethodDeclarator() :{}{    < IDENTIFIER > FormalParameters()}void MethodDefination() :{}{    ReturnType() MethodDeclarator() Block()}void Expression() :{}{    ConditionalOrExpression() [ AssignmentOperator() Expression() ]}void ConditionalOrExpression() :{}{    ConditionalAndExpression()    (        < DOUBLE_OR > ConditionalAndExpression()    )*}void ConditionalAndExpression() :{}{    InclusiveOrExpression()    (        < DOUBLE_AND > InclusiveOrExpression()    )*}void InclusiveOrExpression() :{}{    ExclusiveOrExpression()    (        < OR > ExclusiveOrExpression()    )*}void ExclusiveOrExpression() :{}{    AndExpression()    (        < XOR > AndExpression()    )*}void AndExpression() :{}{    EqualityExpression()    (        < AND > EqualityExpression()    )*}void EqualityExpression() :{}{    RelationalExpression()    (        (            < DOUBLE_EQUAL >        |   < NOT_EQUAL >        )        RelationalExpression()    )*}void RelationalExpression() :{}{    ShiftExpression()    (        (            < LESS_THAN >        |   < GREATER_THAN >        |   < LESS_EQUAL >        |   < GREATER_EQUAL >        )        ShiftExpression()    )*}void ShiftExpression() :{}{    AdditiveExpression()    (        (            < LSHIFT >        |   < RSHIFT >        )        AdditiveExpression()    )*}void AdditiveExpression() :{}{    MultiplicativeExpression()    (        (            < PLUS >        |   < MINUS >        )        MultiplicativeExpression()    )*}void MultiplicativeExpression() :{}{    UnaryExpression()    (        (            < STAR >        |   < SLASH >        |   < PERCENT >        )        UnaryExpression()    )*}void UnaryExpression() :{}{    (        < PLUS >    |   < MINUS >    |   < TILDE >    |   < BANG >    )    UnaryExpression()|   CrementExpression()}void CrementExpression() :{}{    (        < INCREMENT >    |   < DECREMENT >    )    PrimaryExpression()|   PrimaryExpression()    [        < INCREMENT >    |   < DECREMENT >    ]}void PrimaryExpression() :{}{    PrimaryPrefix()    [        LOOKAHEAD(1)        PrimarySuffix()    ]}void PrimarySuffix() :{}{    "[" Expression() "]"|   Arguments()|   < PRE_LEN >|   < PRE_ADDRESS>}void PrimaryPrefix() :{}{    Literal()|   "(" Expression() ")"|   < IDENTIFIER >}void Literal() :{}{    < DECIMAL_NUMBER >|   < REAL_NUMBER >|   BooleanLiteral()}void BooleanLiteral() :{}{    < TRUE >|   < FALSE >}void AssignmentOperator() :{}{    < ASSIGN >|   < STARASSIGN >|   < SLASHASSIGN >|   < PERCENTASSIGN >|   < PLUSASSIGN >|   < MINUSASSIGN >|   < LSHIFTASSIGN >|   < RSHIFTASSIGN >|   < ANDASSIGN >|   < XORASSIGN >|   < ORASSIGN >}void ArgumentList() :{}{    Expression()    (        "," Expression()    )*}void Arguments() :{}{    "(" [ ArgumentList() ] ")"}void Statement() :{}{    Block()|   EmptyStatement()|   StatementExpression() ";"|   IfStatement()|   WhileStatement()|   ForStatement()|   BreakStatement()|   ContinueStatement()|   ReturnStatement()|   WriteStatement()|   ReadStatement()}void WriteStatement() :{}{    < WRITE >    (        Expression()    |   < STR >    )    ";"}void ReadStatement() :{}{    < READ > Expression() ";"}void Block() :{}{    "{"    (        BlockStatement()    )*    "}"}void BlockStatement() :{}{    (        Type() < IDENTIFIER >        (            "("            [                FormalParameter()                (                    "," FormalParameter()                )*            ]            ")"        |   [ < ASSIGN > Expression() ]            (                "," VariableDeclarator()            )*        )        ";"    )|    (        < VOID > < IDENTIFIER > "("        [            FormalParameter()            (                "," FormalParameter()            )*        ]        ")"    )    ";"|   Statement()}void LocalVariableDeclaration() :{}{    Type() VariableDeclarator()    (        "," VariableDeclarator()    )*}void VariableDeclarator() :{}{    < IDENTIFIER > [ < ASSIGN > Expression() ]}void IfStatement() :{}{    < IF > "(" Expression() ")" Statement()    [        LOOKAHEAD(1)        < ELSE > Statement()    ]}void WhileStatement() :{}{    < WHILE > "(" Expression() ")" Statement()}void ForStatement() :{}{    < FOR > "(" [ ForInit() ] ";" [ Expression() ] ";" [ ForUpdate() ] ")" Statement()}void ForInit() :{}{    LocalVariableDeclaration()|   StatementExpressionList()}void StatementExpressionList() :{}{    StatementExpression()    (        "," StatementExpression()    )*}void ForUpdate() :{}{    StatementExpressionList()}void BreakStatement() :{}{    < BREAK > ";"}void ContinueStatement() :{}{    < CONTINUE > ";"}void ReturnStatement() :{}{    < RETURN > [ Expression() ] ";"}void EmptyStatement() :{}{    ";"}void StatementExpression() :{}{    (        < INCREMENT > PrimaryExpression()    )|    (        < DECREMENT > PrimaryExpression()    )|   PrimaryExpression()    [        < INCREMENT >    |   < DECREMENT >    |   AssignmentOperator() Expression()    ]}void CompilationUnit() :{}{    (        (            Type() < IDENTIFIER >            (                (                    "("                    [                        FormalParameter()                        (                            "," FormalParameter()                        )*                    ]                    ")" Block()                )            |                (                    [ < ASSIGN > Expression() ]                    (                        "," VariableDeclarator()                    )*                    ";"                )            )        )    |        (            < VOID > < IDENTIFIER > "("            [                FormalParameter()                (                    "," FormalParameter()                )*            ]            ")" Block()        )    )*    < EOF >}
